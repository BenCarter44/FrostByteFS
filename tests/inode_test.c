#include "stdlib.h"
#include "rawdisk.h"
#include "allocator.h"
#include "inode.h"
#include <stdio.h>
#include <fcntl.h>

uint8_t* buffer;

void create_data(uint8_t* buf, off_t size)
{
    for(unsigned int i = 0; i < size; i++)
    {
        buf[i] = (uint8_t)(i % 256);
    }
}


void clear_buffer()
{
    for(unsigned int i = 0; i < BYTES_PER_BLOCK; i++)
    {
        buffer[i] = 0;
    }
}

bool is_blank(uint8_t* buffer)
{
    for(unsigned int i = 0; i < BYTES_PER_BLOCK; i++)
    {
        if(buffer[i])
        {
            return false;
        }
    }
    return true;
}

// autogenerated func below
void print_hex(const uint8_t *data, size_t len) {
    printf("\n============\n");
    for (size_t i = 0; i < len; i++) {
        printf("%02x ", data[i]);
    }
    printf("\n============\n");
}

void format()
{
    clear_ref_blocks();
    clear_inode_blocks();
    format_super_block();
    // add other format commands here for the upper layers.
}

void trigger_print_inode(struct inode node)
{
    printf("Trigger INODE Use GDB and type `p node` after pressing `n`\n");
    return;
}

void trigger_print_directory_entry(directory_entry* dent)
{
    printf("Trigger INODE Use GDB and type `p dent[<index>]` after pressing `n`\n");
    return;
}

void check_format_inodes()
{
    /*
    Formatted INODES:
    Expected values:
        INODE BLOCK
           0 - INODE_BITMAP_BLOCKS-1 : 0

    */
    printf("Checking format...\n");
    memset(buffer, 0, BYTES_PER_BLOCK);
    for(int b = 0; b < INODE_BITMAP_BLOCKS; b++)
    {
        read_inode_block(buffer, b);
        if(b == 0 && buffer[0] == 0x03)
        {
            continue;
        }
        if(!is_blank(buffer))
        {
            fprintf(stderr, "Failed format: not blank inode bitmap\n");
            exit(-1);
        }
    }
    // Check Root INODE
    memset(buffer, 0, BYTES_PER_BLOCK);
    read_inode_block(buffer, INODE_TABLE_START_BLOCK);
    struct inode* ilist = (struct inode*)buffer;
    struct inode root = ilist[1]; // root inode is 1
    if(
        root.mode != (S_IFDIR | 0755) ||
        root.nlink != 2 ||
        root.size != sizeof(directory_entry) * 3 ||
        root.direct_blocks[0] != 1 ||
        root.direct_blocks[1] != 0 ||
        root.direct_blocks[2] != 0 ||
        root.direct_blocks[3] != 0 ||
        root.direct_blocks[4] != 0 ||
        root.direct_blocks[5] != 0 ||
        root.direct_blocks[6] != 0 ||
        root.direct_blocks[7] != 0 ||
        root.direct_blocks[8] != 0 ||
        root.direct_blocks[9] != 0 ||
        root.direct_blocks[10] != 0 ||
        root.direct_blocks[11] != 0 ||
        root.single_indirect != 0 ||
        root.double_indirect != 0 ||
        root.triple_indirect != 0
    )
    {
        fprintf(stderr, "Failed format: Invalid root INODE\n");
        trigger_print_inode(root);
        exit(-1);
    }

    // check root data block
    memset(buffer, 0, BYTES_PER_BLOCK);
    int r = read_data_block(buffer, 1);
    if(r < 0)
    {
        fprintf(stderr, "Failed format: Invalid root data block: ret: %d\n", r);
        exit(-1);
    }
    directory_entry* dent_list = (directory_entry*)buffer;
    if(
        dent_list[0].name[0] != '.' ||
        dent_list[0].name[1] != 0   ||  // tests '.'
        dent_list[0].inum != 1      ||
        dent_list[0].is_valid != 1  ||
        dent_list[1].name[0] != '.' ||
        dent_list[1].name[1] != '.' ||  // tests '..'
        dent_list[1].name[2] != 0   ||
        dent_list[1].inum != 1      ||
        dent_list[1].is_valid != 1  ||
        dent_list[2].is_valid != 0
    ) 
    {
        fprintf(stderr, "Failed format: Invalid root data block\n");
        trigger_print_directory_entry(dent_list);
        exit(-1);
    }
}

void check_create_file(uint64_t parent_inum, uint64_t expected_child_inum, const char* path)
{
    uint64_t out_inum = 0;
    int r = inode_create(path, S_IFREG | 0644, &out_inum);
    if(r < 0)
    {
        fprintf(stderr, "Failed create: ret: %d \n",r);
        exit(-1);
    }

    if(out_inum != expected_child_inum)
    {
        fprintf(stderr, "Failed create (inum not %d): %d \n",expected_child_inum,out_inum);
        exit(-1);
    }

    // check if inode is present.
    // Check Root INODE
    memset(buffer, 0, BYTES_PER_BLOCK);
    read_inode_block(buffer, INODE_TABLE_START_BLOCK + expected_child_inum / INODES_PER_BLOCK);
    struct inode* ilist = (struct inode*)buffer;
    struct inode new_inode = ilist[expected_child_inum % INODES_PER_BLOCK]; // root inode is 1
    if(
        new_inode.mode != (S_IFREG | 0644) ||
        new_inode.nlink != 1 ||
        new_inode.size != 0 ||
        new_inode.direct_blocks[0] != 0 ||
        new_inode.direct_blocks[1] != 0 ||
        new_inode.direct_blocks[2] != 0 ||
        new_inode.direct_blocks[3] != 0 ||
        new_inode.direct_blocks[4] != 0 ||
        new_inode.direct_blocks[5] != 0 ||
        new_inode.direct_blocks[6] != 0 ||
        new_inode.direct_blocks[7] != 0 ||
        new_inode.direct_blocks[8] != 0 ||
        new_inode.direct_blocks[9] != 0 ||
        new_inode.direct_blocks[10] != 0 ||
        new_inode.direct_blocks[11] != 0 ||
        new_inode.single_indirect != 0 ||
        new_inode.double_indirect != 0 ||
        new_inode.triple_indirect != 0
    )
    {
        fprintf(stderr, "Failed inode create: Invalid inode for test INODE\n");
        trigger_print_inode(new_inode);
        exit(-1);
    }

    // check root directory root data block
    memset(buffer, 0, BYTES_PER_BLOCK);
    read_inode_block(buffer, INODE_TABLE_START_BLOCK + parent_inum / INODES_PER_BLOCK);
    struct inode* plist = (struct inode*)buffer;
    struct inode parent_inode = plist[parent_inum % INODES_PER_BLOCK]; // root inode is 1
    
    uint8_t* buf2;
    create_buffer((void**)&buf2);

    memset(buf2, 0, BYTES_PER_BLOCK);
    r = read_data_block(buf2, parent_inode.direct_blocks[0]);
    if(r < 0)
    {
        fprintf(stderr, "Failed inode create: Invalid data block: ret: %d\n", r);
        exit(-1);
    }
    directory_entry* dent_list = (directory_entry*)buf2;
    trigger_print_directory_entry(dent_list);
    free(buf2);
}


void check_truncate(uint64_t inum, off_t size)
{
    uint64_t out_inum = 0;
    int r = inode_truncate(inum, size);
    if(r < 0)
    {
        fprintf(stderr, "Failed truncate: ret: %d \n",r);
        exit(-1);
    }

    // check if inode is present.
    // Check Root INODE
    memset(buffer, 0, BYTES_PER_BLOCK);
    read_inode_block(buffer, INODE_TABLE_START_BLOCK + inum / INODES_PER_BLOCK);
    struct inode* ilist = (struct inode*)buffer;
    struct inode new_inode = ilist[inum % INODES_PER_BLOCK]; // root inode is 1
    if(
        new_inode.mtime == 0  ||
        new_inode.size != size ||
        new_inode.direct_blocks[0] != 0 ||
        new_inode.direct_blocks[1] != 0 ||
        new_inode.direct_blocks[2] != 0 ||
        new_inode.direct_blocks[3] != 0 ||
        new_inode.direct_blocks[4] != 0 ||
        new_inode.direct_blocks[5] != 0 ||
        new_inode.direct_blocks[6] != 0 ||
        new_inode.direct_blocks[7] != 0 ||
        new_inode.direct_blocks[8] != 0 ||
        new_inode.direct_blocks[9] != 0 ||
        new_inode.direct_blocks[10] != 0 ||
        new_inode.direct_blocks[11] != 0 ||
        new_inode.single_indirect != 0 ||
        new_inode.double_indirect != 0 ||
        new_inode.triple_indirect != 0
    )
    {
        fprintf(stderr, "Failed inode truncate: inode not cleared!\n");
        trigger_print_inode(new_inode);
        exit(-1);
    }
}

void check_write(uint64_t inum, off_t resulting_size)
{
    memset(buffer, 0, BYTES_PER_BLOCK);
    read_inode_block(buffer, INODE_TABLE_START_BLOCK + inum / INODES_PER_BLOCK);
    struct inode* ilist = (struct inode*)buffer;
    struct inode new_inode = ilist[inum % INODES_PER_BLOCK]; // root inode is 1
    if(
        new_inode.mtime == 0  ||
        new_inode.size != resulting_size || 
        new_inode.direct_blocks[0] <= 1
    )
    {
        fprintf(stderr, "Failed inode write: inode is linking to root!\n");
        trigger_print_inode(new_inode);
        exit(-1);
    }
    trigger_print_inode(new_inode);

}

int main(int argc, char** argv)
{

    printf("Number of total blocks: %u\n", DISK_SIZE_IN_BLOCKS);
    printf("Number of bytes per block: %u\n", BYTES_PER_BLOCK);
    printf("Number of INODE blocks: %u\n", INODE_BLOCKS);
    printf("Number of Reference blocks: %u\n", REF_BLOCKS);
    printf("Number of Data Blocks: %u\n", DATA_BLOCKS);
    printf("Super block position: %u\n",SUPER_BLOCK);
    printf("Reference base block: %u\n", REFERENCE_BASE_BLOCK);
    printf("Inode base block reference: %u\n", INODE_BASE_BLOCK);
    printf("Data base block: %u\n", DATA_BASE_BLOCK);

    int result = open_disk("/dev/vdb");

    printf("Result on opening disk: %s\n", raw_disk_error_to_string(result));
    if(result < 0)
    {
        exit(1);
    }

    create_buffer((void**)&buffer);
    clear_buffer();

    init_allocator();
    
    // format disk
    printf("Formatting...\n");
    clear_ref_blocks();
    clear_inode_blocks();
    format_super_block();
    format_inodes();

    // check format
    check_format_inodes();

    uint64_t test = 0;
    write_to_next_free_block(buffer, &test);
    if(test != 2)
    {
        fprintf(stderr, "Next free block not two! Will override root datablock!\n");
        exit(-1);
    }

    // verify allocator
    memset(buffer, 0, BYTES_PER_BLOCK);
    read_block_raw(buffer, REFERENCE_BASE_BLOCK);
    if(buffer[0] != 1 || buffer[1] != 1 || buffer[2] != 1)
    {
        fprintf(stderr, "Allocator bitmap modified!\n");
        exit(-1);
    }

    // create file (inode_create)
    // assumes short directories.
    printf("Create file '/tt' \n");
    check_create_file(1, 2, "/tt");
    printf("Create file '/tv' \n"); 
    check_create_file(1, 3, "/tv");

    // truncate file
    printf("Truncate file '/tt' \n");
    check_truncate(2, 0);

    // write to file
    // printf("Write to file '/tt' \n");
    uint8_t* buffer_data = malloc(BYTES_PER_BLOCK * 17);
    create_data(buffer_data, BYTES_PER_BLOCK * 17);
    // inode_write(2, buffer_data, BYTES_PER_BLOCK - 100, 0);

    // check_write(2, BYTES_PER_BLOCK - 100);
    
    // printf("Write more to file '/tt' \n");
    
    // for(int i = 0; i < NUM_DIRECT_BLOCKS; i++)
    // {
    //     printf("Writing data: %u  / %u \r", i, NUM_DIRECT_BLOCKS);
    //     fflush(stdout);
    //     inode_write(2, buffer_data, BYTES_PER_BLOCK, 0);
    // }
    // for(int i = 0; i < POINTERS_PER_BLOCK; i++)
    // {
    //     printf("Writing data: %u  / %u \r", i, POINTERS_PER_BLOCK);
    //     fflush(stdout);
    //     inode_write(2, buffer_data, BYTES_PER_BLOCK, NUM_DIRECT_BLOCKS * BYTES_PER_BLOCK + i);
    // }
    // // for(int i = 0; i < POINTERS_PER_BLOCK * POINTERS_PER_BLOCK; i++)
    // // {
    // //     printf("Writing data: %u  / %u \r", i, POINTERS_PER_BLOCK * POINTERS_PER_BLOCK);
    // //     fflush(stdout);
    // //     inode_write(2, buffer_data, BYTES_PER_BLOCK, (POINTERS_PER_BLOCK + NUM_DIRECT_BLOCKS) * BYTES_PER_BLOCK);
    // // }
    // for(int i = 0; i < 20000; i++)
    // {
    //     printf("Writing data: %u  / %u \r", i, 20000);
    //     fflush(stdout);
    //     inode_write(2, buffer_data, BYTES_PER_BLOCK, (POINTERS_PER_BLOCK + NUM_DIRECT_BLOCKS) * BYTES_PER_BLOCK);
    // }
    // printf("\nDone writing...\n");
    // check_write(2, BYTES_PER_BLOCK * (POINTERS_PER_BLOCK + NUM_DIRECT_BLOCKS + POINTERS_PER_BLOCK * POINTERS_PER_BLOCK + 20000));



    printf("Write to file '/tv' \n");
    inode_write(3, buffer_data, BYTES_PER_BLOCK - 50, 0);
    check_write(3, BYTES_PER_BLOCK - 50);
    
    printf("Write more to file '/tv' \n");
    inode_write(3, buffer_data, BYTES_PER_BLOCK, BYTES_PER_BLOCK - 50); 
    check_write(3, BYTES_PER_BLOCK * 2 - 50);

    printf("Truncate file '/tv' \n");
    check_truncate(3, 0);

    


    printf("PASS\n");
    close_disk();
    free_buffer(buffer);

}

