#include "fusefile.h"
#include <stdio.h>
/**
 * @file fusedirectory.c
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2025-11-14
 * 
 * @copyright Copyright (c) 2025
 * 
 */


 /* Other Functions */
void print_fuse_info(struct fuse_file_info* finfo)
{
    if(finfo == NULL)
    {
        printf("Fuse Info NULL\n");
        return;
    }
    printf("Fuse INFO -------------\n");
    printf(" Flags: \t%d\n",finfo->flags);
    printf(" Write Page: \t%u\n",finfo->writepage);
    printf(" Direct IO: \t%u\n",finfo->direct_io);
    printf(" Keep Cache: \t%u\n",finfo->keep_cache);
    printf(" Flush: \t%u\n",finfo->flush);
    printf(" NonSeek: \t%u\n",finfo->nonseekable);
    printf(" FlockRelease: \t%u\n",finfo->flock_release);
    printf(" CacheReadDir: \t%u\n",finfo->cache_readdir);
    printf(" NoFlush: \t%u\n",finfo->noflush);
    printf(" PDirectWrite: \t%u\n",finfo->parallel_direct_writes);
    printf(" FH: \t%" PRIu64 "\n",finfo->fh);
    printf(" LockOwner: \t%" PRIu64 "\n",finfo->lock_owner);
    printf(" PollEvt: \t%u\n",finfo->poll_events);
    printf(" BackingID: \t%d\n",finfo->backing_id);
    printf(" ComptFlag: \t%" PRIu64 "\n",finfo->compat_flags);
    printf("------------------\n");
}

// TODO: Fetch path function (get INODE number from path). Move the func to here instead of in inode.h
// Remove all "fuse stuff" in INODE layer. Fusefile / fusedirectory are the only ones that can do "fuse stuff"
// Translate fuse calls to inode calls. 

/* Private Functions */
int get_inode_from_path(const char* path, uint32_t* inode, uint32_t* previous);
static int get_inode_from_path_rec(const char* path, uint32_t inode_root, uint32_t* inode, uint32_t* previous);

static const char* basename(const char* path) {
    const char* slash = strrchr(path, '/');
    return slash ? slash + 1 : path;
}



int get_inode_from_path(const char* path, uint32_t* inode, uint32_t* previous)
{
    if(strcmp("/", path) == 0)
    {
        *inode = return_root_inode();
        *previous = return_root_inode();
        return 0;
    }
    return get_inode_from_path_rec(&path[1], return_root_inode(), inode, previous);
}


static int get_inode_from_path_rec(const char* path, uint32_t inode_root, uint32_t* inode, uint32_t* previous)
{
    printf("Processing '%s' Root Node: %u \n",path, inode_root);
    // if is a file and path is finished, return root
    if(!is_inode_a_directory(inode_root) && path[0] == 0)
    {
        *inode = inode_root;
        return 0;
    }
    // if is a file and path is not finished, return error.
    if(!is_inode_a_directory(inode_root))
    {
        return -FILE_NOT_FOUND;
    }
    // if is a directory and file is finished, return inode
    if(is_inode_a_directory(inode_root) && path[0] == 0)
    {
        *inode = inode_root;
        return 0;
    }

    // path still has contents
    
    // get next path
    char buffer[MAX_FILENAME_LENGTH];
    for(int i = 0; i < MAX_FILENAME_LENGTH; i++)
    {
        buffer[i] = 0;
    }
    uint32_t index = 0; 
    while(path[index] != 0 && path[index] != '/')
    {
        buffer[index] = path[index];
        index++;
    }

    int i = get_inode_given_name(inode_root, buffer);
    if(i < 0)
    {
        return -FILE_NOT_FOUND;
    }
    if(path[index] == 0)
    {
        return get_inode_from_path_rec(NULL, i, inode,previous);
    }
    *previous = inode_root;
    return get_inode_from_path_rec(&path[index+1], i, inode, previous);    

}



/* ----------------------------- File Ops ----------------------------- */
// autogenerated
int validate_open_flags(int flags)
{
    if(flags & __O_TMPFILE)
    {
        return EOPNOTSUPP;
    }
    /* -------------------------
       1. Access mode must exist
       ------------------------- */
    int mode = flags & O_ACCMODE;
    if (mode != O_RDONLY && mode != O_WRONLY && mode != O_RDWR)
        return EINVAL;

    /* -------------------------
       2. O_EXCL requires O_CREAT (except for block devices)
       ------------------------- */
    if ((flags & O_EXCL) && !(flags & O_CREAT))
        return EINVAL;   /* man page: undefined except for block devs */

    /* -------------------------
       3. O_TMPFILE rules
       ------------------------- */
#ifdef O_TMPFILE
    if (flags & O_TMPFILE) {
        return EOPNOTSUPP;
    }
#endif

    /* -------------------------
       4. O_CREAT + O_DIRECTORY is invalid on Linux >= 6.4
       ------------------------- */
#if defined(__linux__)
    if ((flags & O_CREAT) && (flags & O_DIRECTORY)) {
        return EINVAL;
    }
#endif

    /* -------------------------
       5. O_TRUNC requires write access
       ------------------------- */
    if ((flags & O_TRUNC) && !(mode == O_WRONLY || mode == O_RDWR))
        return EINVAL;

    /* -------------------------
       6. O_APPEND is always allowed; no rule prohibits combinations.
       ------------------------- */

    /* -------------------------
       7. O_PATH semantics
       ------------------------- */
#ifdef O_PATH
    if (flags & O_PATH) {
        /* Only these flags are allowed with O_PATH:
           O_PATH, O_CLOEXEC, O_NOFOLLOW, O_DIRECTORY
         */
        int allowed = O_PATH | O_CLOEXEC | O_NOFOLLOW | O_DIRECTORY;
        if (flags & ~allowed)
            return EINVAL;
    }
#endif

    /* -------------------------
       8. O_DIRECT may give EINVAL if FS does not support it.
       We cannot test that here.
       ------------------------- */

    /* -------------------------
       9. O_NONBLOCK always allowed
       ------------------------- */

    /* All statically detectable constraints passed */
    return 0;
}


int frostbyte_open(const char* path, struct fuse_file_info* finfo) 
{
    // flat failures
    int r = validate_open_flags(finfo->flags);
    if(r != 0)
    {
        errno = r;
        return -r;
    }

    uint32_t inode = 0;
    uint32_t parent_inode = 0;
    
    FrostByteFile* file = NULL;

    // Is it a new file?
    r = get_inode_from_path(path, &inode, &parent_inode);
    if(r == -FILE_NOT_FOUND)
    {
        // file is new file
        if(!(finfo->flags & O_CREAT))
        {
            errno = ENOENT;
            return -ENOENT;
        }
        // create new file
        inode = inode_create(parent_inode, basename(path));
        file = file_create_new(inode);
        finfo->fh = (uint64_t)file;
    }
    if(finfo->flags & O_EXCL && r != -FILE_NOT_FOUND)
    {
        errno = EEXIST;
        return -EEXIST;
    }

    // What should be done if new file?
    if(finfo->flags & O_TRUNC)
    {
        file_truncate(file, 0);
    }

    if(finfo->flags & O_APPEND)
    {
        file_seek(file, 1, 0);
    }

    // What should the permissions be?
    file_set_access(file, finfo->flags);
     
    printf("frostbyte_open(path=\"%s\")\n", path);
    print_fuse_info(finfo);
    return 0;
}



int frostbyte_unlink(const char* path) 
{
    // see https://www.man7.org/linux/man-pages/man2/open.2.html for error codes
    
    // file not found!
    uint32_t inode = 0;
    uint32_t previous = 0;
    int r = get_inode_from_path(path, &inode, &previous);
    if(r == -FILE_NOT_FOUND)
    {
        errno = ENOENT;
        return -ENOENT;
    }

    if(is_inode_a_directory(inode))
    {
        errno = EISDIR;
        return -EISDIR;
    };

    inode_unlink(inode); 
    printf("frostbyte_unlink(path=\"%s\")\n", path);
    return 0;
}

int frostbyte_rename(const char* path_old, const char* path_new, unsigned int flags) 
{
    uint32_t inode = 0;
    uint32_t previous = 0;
    int r = get_inode_from_path(path_old, &inode, &previous);
    if(r == -FILE_NOT_FOUND)
    {
        errno = ENOENT;
        return -ENOENT;
    }

    inode_rename(inode, path_new);

    printf("frostbyte_rename(old=\"%s\", new=\"%s\", flags=%u)\n",
           path_old, path_new, flags);
    return 0;
}

int frostbyte_flush(const char* path, struct fuse_file_info* finfo) 
{
    uint32_t inode = 0;
    uint32_t previous = 0;
    int r = get_inode_from_path(path, &inode, &previous);
    if(r == -FILE_NOT_FOUND)
    {
        errno = ENOENT;
        return -ENOENT;
    }
    if(is_inode_a_directory(inode))
    {
        errno = EISDIR;
        return -EISDIR;
    };

    // Do nothing?

    printf("frostbyte_flush(path=\"%s\")\n", path);
    print_fuse_info(finfo);
    return 0;
}

int frostbyte_release(const char* path, struct fuse_file_info* finfo) 
{
    uint32_t inode = 0;
    uint32_t previous = 0;
    int r = get_inode_from_path(path, &inode, &previous);
    if(r == -FILE_NOT_FOUND)
    {
        errno = ENOENT;
        return -ENOENT;
    }
    if(is_inode_a_directory(inode))
    {
        errno = EISDIR;
        return -EISDIR;
    };

    if(finfo->fh == 0)
    {
        errno = EBADF;
        return -EBADF;
    }

    file_close((FrostByteFile*)finfo->fh);

    printf("frostbyte_release(path=\"%s\")\n", path);
    print_fuse_info(finfo);
    return 0;
}

int frostbyte_create(const char* path, mode_t fmode, struct fuse_file_info* finfo) 
{  
    printf("frostbyte_create(path=\"%s\", mode=%o)\n", path, fmode);
    print_fuse_info(finfo);
    int32_t i = finfo->flags | O_CREAT | O_WRONLY | O_TRUNC;
    finfo->flags = i;

    return frostbyte_open(path, finfo);
}

// int frostbyte_mknod(const char* path, mode_t fmode, dev_t fdev) 
// {
//     printf("frostbyte_mknod(path=\"%s\", mode=%o, dev=%lu)\n",
//            path, fmode, (unsigned long)fdev);
//     return 0;
// }

int frostbyte_fsync(const char* path, int fint, struct fuse_file_info* finfo) 
{
    printf("frostbyte_fsync(path=\"%s\", fint=%d)\n", path, fint);
    print_fuse_info(finfo);
    return frostbyte_flush(path, finfo);
    return 0;
}


/* ----------------------------- Attributes ----------------------------- */

int frostbyte_getattr(const char* path, struct stat* fstat, struct fuse_file_info* finfo) 
{
    uint32_t inode = 0;
    uint32_t previous = 0;
    int r = get_inode_from_path(path, &inode, &previous);
    if(r == -FILE_NOT_FOUND)
    {
        errno = ENOENT;
        return -ENOENT;
    }

    inode_fstat(inode, fstat);

    printf("frostbyte_getattr(path=\"%s\", stat=%p)\n", path, (void*)fstat);
    print_fuse_info(finfo);
    return 0;
}

int frostbyte_chmod(const char* path, mode_t fmode, struct fuse_file_info* finfo) 
{
    uint32_t inode = 0;
    uint32_t previous = 0;
    int r = get_inode_from_path(path, &inode, &previous);
    if(r == -FILE_NOT_FOUND)
    {
        errno = ENOENT;
        return -ENOENT;
    }

    // change permissions
    inode_chmod(inode, fmode);

    printf("frostbyte_chmod(path=\"%s\", mode=%o)\n", path, fmode);
    print_fuse_info(finfo);
    return 0;
}

int frostbyte_chown(const char* path, uid_t user, gid_t group, struct fuse_file_info* finfo) 
{
    uint32_t inode = 0;
    uint32_t previous = 0;
    int r = get_inode_from_path(path, &inode, &previous);
    if(r == -FILE_NOT_FOUND)
    {
        errno = ENOENT;
        return -ENOENT;
    }

    // change permissions
    inode_chown(inode, user, group);

    printf("frostbyte_chown(path=\"%s\", uid=%u, gid=%u)\n",
           path, (unsigned int)user, (unsigned int)group);
    print_fuse_info(finfo);
    return 0;
}

int frostbyte_setxattr(const char* path, const char* key, const char* val, size_t len, int fint) 
{
    uint32_t inode = 0;
    uint32_t previous = 0;
    int r = get_inode_from_path(path, &inode, &previous);
    if(r == -FILE_NOT_FOUND)
    {
        errno = ENOENT;
        return -ENOENT;
    }

    inode_setxattr(inode, key, val, len, fint);

    printf("frostbyte_setxattr(path=\"%s\", key=\"%s\", val=\"%s\", len=%zu, fint=%d)\n",
           path, key, val, len, fint);
    return 0;
}

int frostbyte_getxattr(const char* path, const char* key, char* val, size_t len) 
{
    uint32_t inode = 0;
    uint32_t previous = 0;
    int r = get_inode_from_path(path, &inode, &previous);
    if(r == -FILE_NOT_FOUND)
    {
        errno = ENOENT;
        return -ENOENT;
    }

    inode_getxattr(inode, key, val, len);

    printf("frostbyte_getxattr(path=\"%s\", key=\"%s\", val=%p, len=%zu)\n",
           path, key, (void*)val, len);
    return 0;
}

int frostbyte_listxattr(const char* path, char* val, size_t len) 
{
    uint32_t inode = 0;
    uint32_t previous = 0;
    int r = get_inode_from_path(path, &inode, &previous);
    if(r == -FILE_NOT_FOUND)
    {
        errno = ENOENT;
        return -ENOENT;
    }

    inode_listxattr(inode, val, len);

    printf("frostbyte_listxattr(path=\"%s\", val=%p, len=%zu)\n",
           path, (void*)val, len);
    return 0;
}

int frostbyte_removexattr(const char* path, const char* key) 
{
    uint32_t inode = 0;
    uint32_t previous = 0;
    int r = get_inode_from_path(path, &inode, &previous);
    if(r == -FILE_NOT_FOUND)
    {
        errno = ENOENT;
        return -ENOENT;
    }

    inode_removexattr(inode, key);

    printf("frostbyte_removexattr(path=\"%s\", key=\"%s\")\n",
           path, key);
    return 0;
}

// int frostbyte_check_access(const char* path, int perm) 
// {
//     uint32_t inode = 0;
//     int r = get_inode_from_path(path, &inode);
//     if(r == -FILE_NOT_FOUND)
//     {
//         errno = ENOENT;
//         return -ENOENT;
//     }

//     inode_check_access(inode, perm);
    
//     // check access

//     printf("frostbyte_check_access(path=\"%s\", perm=%d)\n", path, perm);
//     return 0;
// }

// int frostbyte_statx(const char* path, int flags, int mask, struct statx* stxbuf, struct fuse_file_info* finfo) 
// {
//     printf("frostbyte_statx(path=\"%s\", flags=%d, mask=%d, stxbuf=%p)\n",
//            path, flags, mask, (void*)stxbuf);
//     print_fuse_info(finfo);
//     return 0;
// }


/* ----------------------------- Data I/O ----------------------------- */

int frostbyte_truncate(const char* path, off_t offset, struct fuse_file_info* finfo) 
{
    if(finfo->fh == 0)
    {
        errno = EBADF;
        return -EBADF;
    }
    file_truncate((FrostByteFile*)finfo->fh, offset);

    printf("frostbyte_trucate(path=\"%s\", offset=%ld)\n",
           path, (long)offset);
    print_fuse_info(finfo);
    return 0;
}

int frostbyte_read(const char* path, char* buffer, size_t len, off_t offset, struct fuse_file_info* finfo) 
{
    if(finfo->fh == 0)
    {
        errno = EBADF;
        return -EBADF;
    }
    int r = file_read((FrostByteFile*)finfo->fh, buffer, len, offset);
    printf("frostbyte_read(path=\"%s\", buffer=%p, len=%zu, offset=%ld)\n",
           path, (void*)buffer, len, offset);
    print_fuse_info(finfo);
    return r;
}

int frostbyte_write(const char* path, const char* buffer, size_t len, off_t offset, struct fuse_file_info* finfo) 
{
    if(finfo->fh == 0)
    {
        errno = EBADF;
        return -EBADF;
    }
    int r = file_write((FrostByteFile*)finfo->fh, buffer, len, offset);
    printf("frostbyte_write(path=\"%s\", buffer=%p, len=%zu, offset=%ld)\n",
           path, (void*)buffer, len, offset);
    print_fuse_info(finfo);
    return r;
}


// int frostbyte_map_raw(const char* path, size_t blocksize, uint64_t *idx) 
// {
//     uint32_t inode = 0;
//     uint32_t previous = 0;
//     int r = get_inode_from_path(path, &inode, &previous);
//     if(r == -FILE_NOT_FOUND)
//     {
//         errno = ENOENT;
//         return -ENOENT;
//     }
//     printf("frostbyte_map_raw(path=\"%s\", blocksize=%zu, idx=%p)\n",
//            path, blocksize, (void*)idx);
//     return 0;
// }

// int frostbyte_allocate(const char* path, int len, off_t offset,
//                        off_t offset2, struct fuse_file_info* finfo) 
// {    
//     printf("frostbyte_allocate(path=\"%s\", len=%d, offset=%ld, offset2=%ld)\n",
//            path, len, (long)offset, (long)offset2);
//     print_fuse_info(finfo);
//     return 0;
// }

ssize_t frostbyte_copy_file_range(const char *path_in,
                                  struct fuse_file_info *fi_in,
                                  off_t offset_in,
                                  const char *path_out,
                                  struct fuse_file_info *fi_out,
                                  off_t offset_out,
                                  size_t size,
                                  int flags) 
{
    if(fi_in->fh == 0 || fi_out->fh == 0)
    {
        errno = EBADF;
        return -EBADF;
    }
    int r = file_copy_file_range((FrostByteFile*)fi_in->fh, offset_in, (FrostByteFile*)fi_out->fh, offset_out, size);

    printf("frostbyte_copy_file_range(path_in=\"%s\", offset_in=%ld, path_out=\"%s\", "
           "offset_out=%ld, size=%zu, flags=%d)\n",
           path_in, (long)offset_in,
           path_out, (long)offset_out,
           size, flags);

    print_fuse_info(fi_in);
    print_fuse_info(fi_out);
    return r;
}
