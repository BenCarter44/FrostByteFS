/**
 * @file fusefile.c
 * @author Benjamin Carter, Towhidul Islam, Sohaib
 * @brief This handles all fuse callbacks relating to files.
 * @version 0.1
 * @date 2025-11-14
 * 
 * @copyright Copyright (c) 2025
 * 
 */

 /*
 
 This file has all the file callbacks and calls the inode functions respectively.
  
 */

#include "fusefile.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <pthread.h>
#include <limits.h>
#include <assert.h>



 /* Other Functions */
void print_fuse_info(struct fuse_file_info* finfo)
{
    if(finfo == NULL)
    {
        printf("Fuse Info NULL\n");
        return;
    }
    printf("Fuse INFO -------------\n");
    printf(" Flags: \t%d\n",finfo->flags);
    printf(" Write Page: \t%u\n",finfo->writepage);
    printf(" Direct IO: \t%u\n",finfo->direct_io);
    printf(" Keep Cache: \t%u\n",finfo->keep_cache);
    printf(" Flush: \t%u\n",finfo->flush);
    printf(" NonSeek: \t%u\n",finfo->nonseekable);
    printf(" FlockRelease: \t%u\n",finfo->flock_release);
    printf(" CacheReadDir: \t%u\n",finfo->cache_readdir);
    printf(" NoFlush: \t%u\n",finfo->noflush);
    printf(" PDirectWrite: \t%u\n",finfo->parallel_direct_writes);
    printf(" FH: \t%" PRIu64 "\n",finfo->fh);
    printf(" LockOwner: \t%" PRIu64 "\n",finfo->lock_owner);
    printf(" PollEvt: \t%u\n",finfo->poll_events);
    printf(" BackingID: \t%d\n",finfo->backing_id);
    printf(" ComptFlag: \t%" PRIu64 "\n",finfo->compat_flags);
    printf("------------------\n");
}

// TODO: Fetch path function (get INODE number from path). Move the func to here instead of in inode.h
// Remove all "fuse stuff" in INODE layer. Fusefile / fusedirectory are the only ones that can do "fuse stuff"
// Translate fuse calls to inode calls. 



/* ----------------------------- File Ops ----------------------------- */
// autogenerated
int validate_open_flags(int flags)
{
    if(flags & __O_TMPFILE)
    {
        return EOPNOTSUPP;
    }
    /* -------------------------
       1. Access mode must exist
       ------------------------- */
    int mode = flags & O_ACCMODE;
    if (mode != O_RDONLY && mode != O_WRONLY && mode != O_RDWR)
        return EINVAL;

    /* -------------------------
       2. O_EXCL requires O_CREAT (except for block devices)
       ------------------------- */
    if ((flags & O_EXCL) && !(flags & O_CREAT))
        return EINVAL;   /* man page: undefined except for block devs */

    /* -------------------------
       3. O_TMPFILE rules
       ------------------------- */
#ifdef O_TMPFILE
    if (flags & O_TMPFILE) {
        return EOPNOTSUPP;
    }
#endif

    /* -------------------------
       4. O_CREAT + O_DIRECTORY is invalid on Linux >= 6.4
       ------------------------- */
#if defined(__linux__)
    if ((flags & O_CREAT) && (flags & O_DIRECTORY)) {
        return EINVAL;
    }
#endif

    /* -------------------------
       5. O_TRUNC requires write access
       ------------------------- */
    if ((flags & O_TRUNC) && !(mode == O_WRONLY || mode == O_RDWR))
        return EINVAL;

    /* -------------------------
       6. O_APPEND is always allowed; no rule prohibits combinations.
       ------------------------- */

    /* -------------------------
       7. O_PATH semantics
       ------------------------- */
#ifdef O_PATH
    if (flags & O_PATH) {
        /* Only these flags are allowed with O_PATH:
           O_PATH, O_CLOEXEC, O_NOFOLLOW, O_DIRECTORY
         */
        int allowed = O_PATH | O_CLOEXEC | O_NOFOLLOW | O_DIRECTORY;
        if (flags & ~allowed)
            return EINVAL;
    }
#endif

    /* -------------------------
       8. O_DIRECT may give EINVAL if FS does not support it.
       We cannot test that here.
       ------------------------- */

    /* -------------------------
       9. O_NONBLOCK always allowed
       ------------------------- */

    /* All statically detectable constraints passed */
    return 0;
}


int frostbyte_open(const char* path, struct fuse_file_info* finfo) 
{
    // flat failures
    int r = validate_open_flags(finfo->flags);
    if(r != 0)
    {
        errno = r;
        return -r;
    }

    uint32_t inode = 0;
    
    // Is it a new file?
    r = inode_find_by_path(path);
    if(r < 0 && r != -ENOENT)
    {
        return r;
    }
    if(r == -ENOENT)
    {
        // file is new file
        if(!(finfo->flags & O_CREAT))
        {
            errno = ENOENT;
            return -ENOENT;
        }
        // create new file
        r = inode_create(path, S_IFREG | finfo->flags, &inode);
        if(r < 0)
        {
            return r;
        }
        finfo->fh = (uint64_t)inode;
    }
    inode = (uint32_t)r;
    if(finfo->flags & O_EXCL && r != -FILE_NOT_FOUND)
    {
        errno = EEXIST;
        return -EEXIST;
    }

    // What should be done if new file?
    if(finfo->flags & O_TRUNC)
    {
        inode_truncate(inode, 0);
    }

    // What should the permissions be?
    // file_set_access(file, finfo->flags);
     
    printf("frostbyte_open(path=\"%s\")\n", path);
    print_fuse_info(finfo);
    return 0;
}



int frostbyte_unlink(const char* path) 
{
    // see https://www.man7.org/linux/man-pages/man2/open.2.html for error codes
    
    printf("frostbyte_unlink(path=\"%s\")\n", path);
    return inode_unlink(path);
}

int frostbyte_rename(const char* path_old, const char* path_new, unsigned int flags) 
{
    int inode = 0;
    inode = inode_find_by_path(path_old);
    if (inode < 0) {
        return inode;
    }
    
    printf("frostbyte_rename(old=\"%s\", new=\"%s\", flags=%u)\n",
        path_old, path_new, flags);
    return inode_rename(path_old, path_new);

    // return 0;
}

int frostbyte_flush(const char* path, struct fuse_file_info* finfo) 
{
    int inode = 0;
    inode = inode_find_by_path(path);
    if (inode < 0) {
        return inode;
    }
    // Do nothing?

    printf("frostbyte_flush(path=\"%s\")\n", path);
    print_fuse_info(finfo);
    return 0;
}

int frostbyte_release(const char* path, struct fuse_file_info* finfo) 
{
    int inode = 0;
    inode = inode_find_by_path(path);
    if (inode < 0) {
        return inode;
    }

    if(finfo->fh == 0)
    {
        errno = EBADF;
        return -EBADF;
    }

    printf("frostbyte_release(path=\"%s\")\n", path);
    print_fuse_info(finfo);
    return 0;
}

int frostbyte_create(const char* path, mode_t fmode, struct fuse_file_info* finfo) 
{  
    printf("frostbyte_create(path=\"%s\", mode=%o)\n", path, fmode);
    print_fuse_info(finfo);
    int32_t i = finfo->flags | O_CREAT | O_WRONLY | O_TRUNC;
    finfo->flags = i;

    return frostbyte_open(path, finfo);
}

// int frostbyte_mknod(const char* path, mode_t fmode, dev_t fdev) 
// {
//     printf("frostbyte_mknod(path=\"%s\", mode=%o, dev=%lu)\n",
//            path, fmode, (unsigned long)fdev);
//     return 0;
// }

int frostbyte_fsync(const char* path, int fint, struct fuse_file_info* finfo) 
{
    printf("frostbyte_fsync(path=\"%s\", fint=%d)\n", path, fint);
    print_fuse_info(finfo);
    return frostbyte_flush(path, finfo);
    return 0;
}


/* ----------------------------- Attributes ----------------------------- */

int frostbyte_getattr(const char* path, struct stat* stbuf, struct fuse_file_info* finfo) 
{
    int32_t inode = 0;
    inode = inode_find_by_path(path);
    if (inode < 0) {
        return inode;
    }

    struct inode node;
    inode_read_from_disk(inode, &node);

    // --- 3. Copy stats from iNode to stbuf ---
    memset(stbuf, 0, sizeof(struct stat));
    stbuf->st_mode = node.mode;
    stbuf->st_nlink = node.nlink;
    stbuf->st_uid = node.uid;
    stbuf->st_gid = node.gid;
    stbuf->st_size = node.size;
    stbuf->st_ino = inode;
    stbuf->st_atime = node.atime;
    stbuf->st_mtime = node.mtime;
    stbuf->st_ctime = node.ctime;


    printf("frostbyte_getattr(path=\"%s\", stat=%p)\n", path, (void*)fstat);
    print_fuse_info(finfo);
    return 0;
}

int frostbyte_chmod(const char* path, mode_t fmode, struct fuse_file_info* finfo) 
{
    int inode = 0;
    inode = inode_find_by_path(path);
    if (inode < 0) {
        return inode;
    }

    // change permissions
    inode_chmod(inode, fmode);

    printf("frostbyte_chmod(path=\"%s\", mode=%o)\n", path, fmode);
    print_fuse_info(finfo);
    return 0;
}

int frostbyte_chown(const char* path, uid_t user, gid_t group, struct fuse_file_info* finfo) 
{
    int inode = 0;
    inode = inode_find_by_path(path);
    if (inode < 0) {
        return inode;
    }

    // change permissions
    inode_chown(inode, user, group);

    printf("frostbyte_chown(path=\"%s\", uid=%u, gid=%u)\n",
           path, (unsigned int)user, (unsigned int)group);
    print_fuse_info(finfo);
    return 0;
}

int frostbyte_setxattr(const char* path, const char* key, const char* val, size_t len, int fint) 
{
    int inode = 0;
    inode = inode_find_by_path(path);
    if (inode < 0) {
        return inode;
    }

    inode_setxattr(inode, key, val, len, fint);

    printf("frostbyte_setxattr(path=\"%s\", key=\"%s\", val=\"%s\", len=%zu, fint=%d)\n",
           path, key, val, len, fint);
    return 0;
}

int frostbyte_getxattr(const char* path, const char* key, char* val, size_t len) 
{
    int inode = 0;
    inode = inode_find_by_path(path);
    if (inode < 0) {
        return inode;
    }

    inode_getxattr(inode, key, val, len);

    printf("frostbyte_getxattr(path=\"%s\", key=\"%s\", val=%p, len=%zu)\n",
           path, key, (void*)val, len);
    return 0;
}

int frostbyte_listxattr(const char* path, char* val, size_t len) 
{
    int inode = 0;
    inode = inode_find_by_path(path);
    if (inode < 0) {
        return inode;
    }

    inode_listxattr(inode, val, len);

    printf("frostbyte_listxattr(path=\"%s\", val=%p, len=%zu)\n",
           path, (void*)val, len);
    return 0;
}

int frostbyte_removexattr(const char* path, const char* key) 
{
    int inode = 0;
    inode = inode_find_by_path(path);
    if (inode < 0) {
        return inode;
    }

    inode_removexattr(inode, key);

    printf("frostbyte_removexattr(path=\"%s\", key=\"%s\")\n",
           path, key);
    return 0;
}

// int frostbyte_check_access(const char* path, int perm) 
// {
//     uint32_t inode = 0;
//     int r = get_inode_from_path(path, &inode);
//     if(r == -FILE_NOT_FOUND)
//     {
//         errno = ENOENT;
//         return -ENOENT;
//     }

//     inode_check_access(inode, perm);
    
//     // check access

//     printf("frostbyte_check_access(path=\"%s\", perm=%d)\n", path, perm);
//     return 0;
// }

// int frostbyte_statx(const char* path, int flags, int mask, struct statx* stxbuf, struct fuse_file_info* finfo) 
// {
//     printf("frostbyte_statx(path=\"%s\", flags=%d, mask=%d, stxbuf=%p)\n",
//            path, flags, mask, (void*)stxbuf);
//     print_fuse_info(finfo);
//     return 0;
// }


/* ----------------------------- Data I/O ----------------------------- */

int frostbyte_truncate(const char* path, off_t offset, struct fuse_file_info* finfo) 
{
    printf("L3 (FUSE): frost_truncate('%s', size %ld) called.\n", path, offset);

    // --- 1. Find the iNode (L2) ---
    int inum = inode_find_by_path(path);
    if (inum < 0) {
        return inum;
    }
    
    // --- 2. Call the iNode layer's truncate function (L2) ---
    return inode_truncate(inum, offset);
}

int frostbyte_read(const char* path, char* buffer, size_t len, off_t offset, struct fuse_file_info* finfo) 
{
    // (void) fi; // If we used fi->fh, we'd use it here
    printf("L3 (FUSE): frost_read('%s', size %ld, offset %ld) called.\n", path, len, offset);

    // --- 1. Find the iNode (L2) ---
    int inum = inode_find_by_path(path);
    if (inum < 0) {
        return inum;
    }

    // --- 2. Call the iNode layer's read function (L2) ---
    return inode_read(inum, buffer, len, offset);
}

int frostbyte_write(const char* path, const char* buffer, size_t len, off_t offset, struct fuse_file_info* finfo) 
{
    // (void) fi;
    printf("L3 (FUSE): frost_write('%s', size %ld, offset %ld) called.\n", path, len, offset);

    // --- 1. Find the iNode (L2) ---
    int inum = inode_find_by_path(path);
    if (inum < 0) {
        return inum;
    }

    // --- 2. Call the iNode layer's write function (L2) ---
    return inode_write(inum, buffer, len, offset);
}


// int frostbyte_map_raw(const char* path, size_t blocksize, uint64_t *idx) 
// {
//     uint32_t inode = 0;
//     uint32_t previous = 0;
//     int r = get_inode_from_path(path, &inode, &previous);
//     if(r == -FILE_NOT_FOUND)
//     {
//         errno = ENOENT;
//         return -ENOENT;
//     }
//     printf("frostbyte_map_raw(path=\"%s\", blocksize=%zu, idx=%p)\n",
//            path, blocksize, (void*)idx);
//     return 0;
// }

// int frostbyte_allocate(const char* path, int len, off_t offset,
//                        off_t offset2, struct fuse_file_info* finfo) 
// {    
//     printf("frostbyte_allocate(path=\"%s\", len=%d, offset=%ld, offset2=%ld)\n",
//            path, len, (long)offset, (long)offset2);
//     print_fuse_info(finfo);
//     return 0;
// }

ssize_t frostbyte_copy_file_range(const char *path_in,
                                  struct fuse_file_info *fi_in,
                                  off_t offset_in,
                                  const char *path_out,
                                  struct fuse_file_info *fi_out,
                                  off_t offset_out,
                                  size_t size,
                                  int flags) 
{
    int inum = inode_find_by_path(path_in);
    if (inum < 0) {
        return inum;
    }
    int inum2 = inode_find_by_path(path_out);
    if (inum2 < 0) {
        return inum2;
    }
    // assumes everything fits in memory!
    uint8_t* buffer = (uint8_t*)malloc(size);

    int r = inode_read(inum, buffer, size, offset_in);
    if(r < 0)
    {
        free(buffer);
        return r;
    }
    r = inode_write(inum, buffer, size, offset_out);
    if(r < 0)
    {
        free(buffer);
        return r;
    }
    free(buffer);
    printf("frostbyte_copy_file_range(path_in=\"%s\", offset_in=%ld, path_out=\"%s\", "
           "offset_out=%ld, size=%zu, flags=%d)\n",
           path_in, (long)offset_in,
           path_out, (long)offset_out,
           size, flags);
    
    print_fuse_info(fi_in);
    print_fuse_info(fi_out);
    return r;
}
