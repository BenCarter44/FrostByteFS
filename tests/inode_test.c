#include "stdlib.h"
#include "rawdisk.h"
#include "allocator.h"
#include "inode.h"
#include <stdio.h>
#include <fcntl.h>

uint8_t* buffer;

void create_data()
{
    for(unsigned int i = 0; i < BYTES_PER_BLOCK; i++)
    {
        buffer[i] = (uint8_t)(i % 256);
    }
}


void clear_buffer()
{
    for(unsigned int i = 0; i < BYTES_PER_BLOCK; i++)
    {
        buffer[i] = 0;
    }
}

bool is_blank(uint8_t* buffer)
{
    for(unsigned int i = 0; i < BYTES_PER_BLOCK; i++)
    {
        if(buffer[i])
        {
            return false;
        }
    }
    return true;
}

// autogenerated func below
void print_hex(const uint8_t *data, size_t len) {
    printf("\n============\n");
    for (size_t i = 0; i < len; i++) {
        printf("%02x ", data[i]);
    }
    printf("\n============\n");
}

void format()
{
    clear_ref_blocks();
    clear_inode_blocks();
    format_super_block();
    // add other format commands here for the upper layers.
}

void trigger_print_inode(struct inode node)
{
    printf("Trigger INODE Use GDB and type `p node` after pressing `n`\n");
    return;
}

void trigger_print_directory_entry(directory_entry* dent)
{
    printf("Trigger INODE Use GDB and type `p dent[<index>]` after pressing `n`\n");
    return;
}

void check_format_inodes()
{
    /*
    Formatted INODES:
    Expected values:
        INODE BLOCK
           0 - INODE_BITMAP_BLOCKS-1 : 0

    */
    printf("Checking format...\n");
    memset(buffer, 0, BYTES_PER_BLOCK);
    for(int b = 0; b < INODE_BITMAP_BLOCKS; b++)
    {
        read_inode_block(buffer, 0);
        if(!is_blank(buffer))
        {
            fprintf(stderr, "Failed format: not blank inode bitmap\n");
            exit(-1);
        }
    }
    // Check Root INODE
    memset(buffer, 0, BYTES_PER_BLOCK);
    read_inode_block(buffer, INODE_TABLE_START_BLOCK);
    struct inode* ilist = (struct inode*)buffer;
    struct inode root = ilist[1]; // root inode is 1
    if(
        root.mode != S_IFDIR | 0755 ||
        root.nlink != 2 ||
        root.size != sizeof(directory_entry) * 3 ||
        root.direct_blocks[0] != 1 ||
        root.direct_blocks[1] != 0 ||
        root.direct_blocks[2] != 0 ||
        root.direct_blocks[3] != 0 ||
        root.direct_blocks[4] != 0 ||
        root.direct_blocks[5] != 0 ||
        root.direct_blocks[6] != 0 ||
        root.direct_blocks[7] != 0 ||
        root.direct_blocks[8] != 0 ||
        root.direct_blocks[9] != 0 ||
        root.direct_blocks[10] != 0 ||
        root.direct_blocks[11] != 0 ||
        root.single_indirect != 0 ||
        root.double_indirect != 0 ||
        root.triple_indirect != 0
    )
    {
        fprintf(stderr, "Failed format: Invalid root INODE\n");
        trigger_print_inode(root);
        exit(-1);
    }

    // check root data block
    memset(buffer, 0, BYTES_PER_BLOCK);
    int r = read_data_block(buffer, 1);
    if(!r)
    {
        fprintf(stderr, "Failed format: Invalid root data block: ret: %d\n", r);
        exit(-1);
    }
    directory_entry* dent_list = (directory_entry*)buffer;
    if(
        dent_list[0].name[0] != '.' ||
        dent_list[0].name[1] != 0   ||  // tests '.'
        dent_list[0].inum != 1      ||
        dent_list[0].is_valid != 1  ||
        dent_list[1].name[0] != '.' ||
        dent_list[1].name[1] != '.' ||  // tests '..'
        dent_list[1].name[2] != 0   ||
        dent_list[1].inum != 1      ||
        dent_list[1].is_valid != 1  ||
        dent_list[2].is_valid != 0
    ) 
    {
        fprintf(stderr, "Failed format: Invalid root data block\n");
        trigger_print_directory_entry(dent_list);
        exit(-1);
    }
}

int main(int argc, char** argv)
{

    printf("Number of total blocks: %u\n", DISK_SIZE_IN_BLOCKS);
    printf("Number of bytes per block: %u\n", BYTES_PER_BLOCK);
    printf("Number of INODE blocks: %u\n", INODE_BLOCKS);
    printf("Number of Reference blocks: %u\n", REF_BLOCKS);
    printf("Number of Data Blocks: %u\n", DATA_BLOCKS);
    printf("Super block position: %u\n",SUPER_BLOCK);
    printf("Reference base block: %u\n", REFERENCE_BASE_BLOCK);
    printf("Inode base block reference: %u\n", INODE_BASE_BLOCK);
    printf("Data base block: %u\n", DATA_BASE_BLOCK);

    int result = open_disk("/dev/vdb");

    printf("Result on opening disk: %s\n", raw_disk_error_to_string(result));
    if(result < 0)
    {
        exit(1);
    }

    create_buffer((void**)&buffer);
    clear_buffer();


    // format disk
    printf("Formatting...\n");
    clear_ref_blocks();
    clear_inode_blocks();
    format_super_block();
    format_inodes();

    check_format_inodes();



    close_disk();
    free_buffer(buffer);

}

